#include "LightTechnique.hpp"

constexpr const char* pVS = R"||(
#version 330 core

layout (location = 0) in vec3 Position;
layout ( location = 1 ) in vec2 TexCoord;

uniform mat4 gWVP;

out vec2 TexCoord0;

void main(){
    gl_Position = gWVP * vec4( Position, 1.0 );
    TexCoord0 = TexCoord;
}
)||";

constexpr const char* pFS = R"||(
#version 330 core

in vec2 TexCoord0;

out vec4 Fragcolor;

struct DirectionalLight{
    vec3 Color;
    float AmbientIntensity;
};

uniform DirectionalLight gDirectionalLight;
uniform sampler2D gSampler;

void main(){
    Fragcolor = texture2D( gSampler, TexCoord0.xy ) *
        vec4( gDirectionalLight.Color, 1.0f ) *
        gDirectionalLight.AmbientIntensity;
}
)||";


static const int INVALID_LOCATION = 0xFFFFFFFF;

bool LightTechnique::init(){
    if( !Technique::init() )
        return false;

    if( !addShader( GL_VERTEX_SHADER, pVS ) )
        return false;

    if( !addShader( GL_FRAGMENT_SHADER, pFS ) )
        return false;

    if( !finalize() )
        return false;

    wVPLoacation_ = getUniformLocation( "gWVP" );
    samplerLocation_ = getUniformLocation( "gSampler" );
    dirLightColorLocation_ = getUniformLocation( "gDirectionalLight.Color" );
    dirLightAmbientLocation_ = getUniformLocation( "gDirectionalLight.AmbientIntensity" );

    if( dirLightColorLocation_ == INVALID_LOCATION
    || wVPLoacation_ == INVALID_LOCATION
    || samplerLocation_ == INVALID_LOCATION
    || dirLightAmbientLocation_ == INVALID_LOCATION )
        return false;

    return true;
}

void LightTechnique::setWVP(const Matrix4f *wvp){
    glUniformMatrix4fv( wVPLoacation_, 1, GL_TRUE, ( const GLfloat* ) wvp->m );
}

void LightTechnique::setTextureUnit(unsigned textureUnit){
    glUniform1i( samplerLocation_, textureUnit );
}

void LightTechnique::setDirectionLight(const DirectionLight &dl){
    glUniform3f( dirLightColorLocation_, dl.Color.x, dl.Color.y, dl.Color.z );
    glUniform1f( dirLightAmbientLocation_, dl.AmbientIntensivity );
}

